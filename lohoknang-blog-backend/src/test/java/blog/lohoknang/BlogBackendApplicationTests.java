package blog.lohoknang;

import java.util.concurrent.CountDownLatch;

import javax.annotation.Resource;

import org.bson.types.ObjectId;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import blog.lohoknang.repository.BlogRepository;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RunWith(SpringRunner.class)
@SpringBootTest
public class BlogBackendApplicationTests {
    @Resource
    private BlogRepository blogRepository;

    public static final String content = "## 方式一 \n"
            + "\n"
            + "实现`ClientHttpRequestFactory`\n"
            + "\n"
            + "### 依赖\n"
            + "\n"
            + "利用了`junixsocket`这个 native 库以及其对 socket 的封装\n"
            + "\n"
            + "```xml\n"
            + "        <dependency>\n"
            + "            <groupId>com.kohlschutter.junixsocket</groupId>\n"
            + "            <artifactId>junixsocket-core</artifactId>\n"
            + "            <version>2.1.2</version>\n"
            + "        </dependency>\n"
            + "        <dependency>\n"
            + "            <groupId>com.kohlschutter.junixsocket</groupId>\n"
            + "            <artifactId>junixsocket-rmi</artifactId>\n"
            + "            <version>2.1.2</version>\n"
            + "        </dependency>\n"
            + "```\n"
            + "\n"
            + "### 实现\n"
            + "\n"
            + "####  `org.springframework.http.client` \n"
            + "\n"
            + "新建包`org.springframework.http.client`，这是因为使用了具有默认访问权限的一些`Abstract`类\n"
            + "\n"
            + "#### `JnrClientHttpRequestFactory`\n"
            + "\n"
            + "- 在包内新建`JnrClientHttpRequestFactory`类，实现`ClientHttpRequestFactory`接口\n"
            + "\n"
            + "- 新建了具有制定一个`sock`文件的构造器，并转换成`AFUNIXSocketAddress`类，该类为`InetSocketAddress`的子类\n"
            + "\n"
            + "- 实现`createRequest`方法，在该方法创建一个`socket` 连接，并返回`JnrBufferingClientHttpRequest`（下一步将创建）\n"
            + "\n"
            + "```java\n"
            + "public class JnrClientHttpRequestFactory implements ClientHttpRequestFactory {\n"
            + "\n"
            + "    private AFUNIXSocketAddress address;\n"
            + "\n"
            + "    public JnrClientHttpRequestFactory(File socketFile) throws IOException {\n"
            + "        this.address = new AFUNIXSocketAddress(socketFile);\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n"
            + "        AFUNIXSocket sock = AFUNIXSocket.connectTo(address);\n"
            + "        return new JnrBufferingClientHttpRequest(sock, uri, httpMethod);\n"
            + "    }\n"
            + "}\n"
            + "```\n"
            + "\n"
            + "\n"
            + "\n"
            + "#### `JnrBufferingClientHttpRequest`\n"
            + "\n"
            + "- 同样在包内新建`JnrBufferingClientHttpRequest`类，继承`AbstractBufferingClientHttpRequest`\n"
            + "\n"
            + "- 这里创建了三个变量储存构造器传来的参数。分别是`AFUNIXSocket`、`URI`、`HttpMethod`\n"
            + "\n"
            + "- 实现`executeInternal`方法，在这里打印请求\n"
            + "- 实现`getMethodValue`、`getURI`\n"
            + "\n"
            + "```java\n"
            + "    private AFUNIXSocket afunixSocket;\n"
            + "    private URI uri;\n"
            + "    private HttpMethod httpMethod;\n"
            + "\n"
            + "    public JnrBufferingClientHttpRequest(AFUNIXSocket afunixSocket, URI uri, HttpMethod httpMethod) {\n"
            + "        this.afunixSocket = afunixSocket;\n"
            + "        this.uri = uri;\n"
            + "        this.httpMethod = httpMethod;\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws "
            + "IOException {\n"
            + "        OutputStream outputStream = afunixSocket.getOutputStream();\n"
            + "        PrintWriter writer = new PrintWriter(outputStream);\n"
            + "\n"
            + "        writer.println(String.format(\"%s %s HTTP/1.1\", httpMethod, uri));\n"
            + "\n"
            + "        headers\n"
            + "                .forEach((key, values) -> {\n"
            + "                    if (values.isEmpty()) return;\n"
            + "\n"
            + "                    writer.append(key).append(\": \");\n"
            + "                    if (values.size() == 1)\n"
            + "                        writer.append(values.get(0));\n"
            + "                    else\n"
            + "                        values.forEach(value -> writer.append(value).append(\"; \"));\n"
            + "                    writer.append(\"\\r\");\n"
            + "                });\n"
            + "\n"
            + "        writer.println(\"Host: http\");\n"
            + "        writer.println(\"\");\n"
            + "        outputStream.write(bufferedOutput);\n"
            + "        writer.flush();\n"
            + "        writer.close();\n"
            + "        return new JnrClientHttpResponse(afunixSocket);\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public String getMethodValue() {\n"
            + "        return httpMethod.name();\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public URI getURI() {\n"
            + "        return uri;\n"
            + "    }\n"
            + "```\n"
            + "\n"
            + "\n"
            + "\n"
            + "#### `JnrClientHttpResponse`\n"
            + "\n"
            + "- 包内创建`JnrClientHttpResponse`类，继承`AbstractClientHttpResponse`\n"
            + "- 创建`InputStream`、`HttpHeaders`、`statusCode`、`statusTest`等 response 字段\n"
            + "- 在构造器阶段读取响应\n"
            + "  - 首先读取请求行\n"
            + "  - 然后是解析请求头\n"
            + "  - 此时`Inputstream`将标记到剩下的请求体部分\n"
            + "- 其中`readLine`为读取一行数据，`readResponseHead`为读取请求行\n"
            + "- 实现`getRawStatusCode`、`getStatusText`、`getHeaders`方法\n"
            + "- `close`方法参考原生`SimpleClientHttpResponse`\n"
            + "- `getBody`方法返回已经标记到请求体的`inputStream`\n"
            + "\n"
            + "```java\n"
            + "    private InputStream inputStream;\n"
            + "    private HttpHeaders httpHeaders;\n"
            + "    private int statusCode = -1;\n"
            + "    private String statusTest = \"UNKNOWN\";\n"
            + "\n"
            + "    JnrClientHttpResponse(AFUNIXSocket afunixSocket) throws IOException {\n"
            + "        this.inputStream = afunixSocket.getInputStream();\n"
            + "\n"
            + "        readResponseHead(readLine(inputStream));\n"
            + "\n"
            + "        httpHeaders = new HttpHeaders();\n"
            + "        String line;\n"
            + "        while (!(line = readLine(inputStream)).isEmpty()) {\n"
            + "            String[] strings = line.split(\" \", 2);\n"
            + "            httpHeaders.add(strings[0], strings[1]);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public int getRawStatusCode() throws IOException {\n"
            + "        return statusCode;\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public String getStatusText() throws IOException {\n"
            + "        return statusTest;\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public void close() {\n"
            + "        try {\n"
            + "            StreamUtils.drain(this.inputStream);\n"
            + "            this.inputStream.close();\n"
            + "        } catch (Exception ex) {\n"
            + "            // ignore\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public InputStream getBody() throws IOException {\n"
            + "        return inputStream;\n"
            + "    }\n"
            + "\n"
            + "    @Override\n"
            + "    public HttpHeaders getHeaders() {\n"
            + "        return httpHeaders;\n"
            + "    }\n"
            + "\n"
            + "    private void readResponseHead(String line) {\n"
            + "        String[] strings = line.split(\" \", 3);\n"
            + "\n"
            + "        statusCode = Integer.valueOf(strings[1]);\n"
            + "        statusTest = strings[2];\n"
            + "    }\n"
            + "\n"
            + "    private String readLine(InputStream inputStream) throws IOException {\n"
            + "        StringBuilder stringBuilder = new StringBuilder();\n"
            + "\n"
            + "        int ch;\n"
            + "        while ((ch = inputStream.read()) != -1) {\n"
            + "            if (ch == '\\r') {\n"
            + "                //noinspection ResultOfMethodCallIgnored\n"
            + "                inputStream.read();\n"
            + "                return stringBuilder.toString();\n"
            + "            }\n"
            + "\n"
            + "            stringBuilder.append((char) ch);\n"
            + "        }\n"
            + "\n"
            + "        return stringBuilder.toString();\n"
            + "    }\n"
            + "```\n"
            + "\n"
            + "\n"
            + "\n"
            + "### 测试\n"
            + "\n"
            + "编写测试代码\n"
            + "\n"
            + "```java\n"
            + "    @Test\n"
            + "    public void contextLoads() throws IOException {\n"
            + "        RestTemplate restTemplate = new RestTemplate(new JnrClientHttpRequestFactory(Paths.get"
            + "(\"/var/run/docker.sock\").toFile()));\n"
            + "        HttpEntity<String> object = restTemplate.getForEntity(\"/v1.24/images/json\", String.class);\n"
            + "        log.info(objectMapper.writeValueAsString(object));\n"
            + "    }\n"
            + "```\n"
            + "\n"
            + "得到响应\n"
            + "\n"
            + "```reStructuredText\n"
            + "2019-02-05 22:35:57.730  INFO 34943 --- [           main] p.a.t.jnrtest.JnrTestApplicationTests    : "
            + "{\"headers\":{\"Date:\":[\"Tue, 05 Feb 2019 14:35:57 GMT\"],\"Docker-Experimental:\":[\"false\"],"
            + "\"Server:\":[\"Docker/18.09.1 (linux)\"],\"Content-Length:\":[\"327\"],\"Ostype:\":[\"linux\"],"
            + "\"Api-Version:\":[\"1.39\"],\"Content-Type:\":[\"application/json\"]},"
            + "\"body\":\"[{\\\\\"Containers\\\\\":-1,\\\\\"Created\\\\\":1548886792,"
            + "\\\\\"Id\\\\\":\\\\\"sha256:caf27325b298a6730837023a8a342699c8b7b388b8d878966b064a1320043019\\\\\","
            + "\\\\\"Labels\\\\\":null,\\\\\"ParentId\\\\\":\\\\\"\\\\\","
            + "\\\\\"RepoDigests\\\\\":[\\\\\"alpine@sha256"
            + ":b3dbf31b77fd99d9c08f780ce6f5282aba076d70a513a8be859d8d3a4d0c92b8\\\\\"],"
            + "\\\\\"RepoTags\\\\\":[\\\\\"alpine:latest\\\\\"],\\\\\"SharedSize\\\\\":-1,\\\\\"Size\\\\\":5529164,"
            + "\\\\\"VirtualSize\\\\\":5529164}]\\\n"
            + "\",\"statusCodeValue\":200,\"statusCode\":\"OK\"}\n"
            + "```\n"
            + "\n"
            + "\n"
            + "\n"
            + "## 方式二 \n"
            + "\n"
            + "### 依赖\n"
            + "\n"
            + "`OkHttp`\n"
            + "\n"
            + "```xml\n"
            + "        <dependency>\n"
            + "            <groupId>com.kohlschutter.junixsocket</groupId>\n"
            + "            <artifactId>junixsocket-core</artifactId>\n"
            + "            <version>2.1.2</version>\n"
            + "        </dependency>\n"
            + "        <dependency>\n"
            + "            <groupId>com.kohlschutter.junixsocket</groupId>\n"
            + "            <artifactId>junixsocket-rmi</artifactId>\n"
            + "            <version>2.1.2</version>\n"
            + "        </dependency>\n"
            + "        <dependency>\n"
            + "            <groupId>com.squareup.okhttp3</groupId>\n"
            + "            <artifactId>okhttp</artifactId>\n"
            + "            <version>3.12.1</version>\n"
            + "        </dependency>\n"
            + "```\n"
            + "\n"
            + "\n"
            + "\n"
            + "### 实现\n"
            + "\n"
            + "#### `JnrAFUNIXSocketFactory`\n"
            + "\n"
            + "- 新建该类，继承`AFUNIXSocketFactory`\n"
            + "- 创建构造器，如方式一中提供了一个`AFUNIXSocketAddress`变量\n"
            + "- 实现`createSocket`此处需要注意一定要使用`super.createSocket()`以绑定自身`factory`不然解析URL会出错\n"
            + "- 然后`connect`到 UNIX Socket 中获得`fd`文件描述符，并将其返回\n"
            + "- 实现`addressFromHost`直接返回 socket 地址，因为没有`host` 和`port`属性，参数可以直接忽略\n"
            + "\n"
            + "```java\n"
            + "private AFUNIXSocketAddress address;\n"
            + "\n"
            + "public JnrAFUNIXSocketFactory(File socketFile) throws IOException {\n"
            + "    address = new AFUNIXSocketAddress(socketFile);\n"
            + "}\n"
            + "\n"
            + "@Override\n"
            + "public Socket createSocket() throws IOException {\n"
            + "    Socket socket = super.createSocket();\n"
            + "    socket.connect(address);\n"
            + "    return socket;\n"
            + "}\n"
            + "\n"
            + "@Override\n"
            + "protected AFUNIXSocketAddress addressFromHost(String s, int i) throws IOException {\n"
            + "    return address;\n"
            + "}\n"
            + "```\n"
            + "\n"
            + "\n"
            + "\n"
            + "### 测试\n"
            + "\n"
            + "这里使用了`OkHttpClient`的`Builder`以便使用自定义的`socketFactory`\n"
            + "\n"
            + "然后在`RestTemplate`中指定`ClientHttpRequestFactory`\n"
            + "\n"
            + "\n"
            + "\n"
            + "注意这一次 URI 需要加上`schema`如`http`，`host`也需要指定例如`localhost`，以通过 URL 的校验，否则会报错\n"
            + "\n"
            + "不过使用中会被忽略，因为会直接使用指定的`socketFile`\n"
            + "\n"
            + "```java\n"
            + "    @Test\n"
            + "    public void okHttp() throws IOException {\n"
            + "        OkHttpClient.Builder builder = new OkHttpClient.Builder();\n"
            + "        OkHttpClient okHttpClient = builder\n"
            + "                .socketFactory(new JnrAFUNIXSocketFactory(Paths.get(\"/var/run/docker.sock\").toFile()"
            + "))\n"
            + "                .build();\n"
            + "\n"
            + "        OkHttp3ClientHttpRequestFactory okHttp3ClientHttpRequestFactory =\n"
            + "                new OkHttp3ClientHttpRequestFactory(okHttpClient);\n"
            + "\n"
            + "\n"
            + "        RestTemplate restTemplate = new RestTemplate(okHttp3ClientHttpRequestFactory);\n"
            + "        HttpEntity<String> object = restTemplate.getForEntity(\"http://localhost/v1.24/images/json\", "
            + "String.class);\n"
            + "        log.info(objectMapper.writeValueAsString(object));\n"
            + "    }\n"
            + "```\n"
            + "\n"
            + "得到结果\n"
            + "\n"
            + "```reStructuredText\n"
            + "2019-02-05 22:58:01.957  INFO 35177 --- [           main] p.a.t.jnrtest.JnrTestApplicationTests    : "
            + "{\"headers\":{\"Api-Version\":[\"1.39\"],\"Ostype\":[\"linux\"],"
            + "\"Content-Type\":[\"application/json\"],\"Docker-Experimental\":[\"false\"],"
            + "\"Content-Length\":[\"327\"],\"Date\":[\"Tue, 05 Feb 2019 14:58:01 GMT\"],\"Server\":[\"Docker/18.09.1"
            + " (linux)\"]},\"body\":\"[{\\\\\"Containers\\\\\":-1,\\\\\"Created\\\\\":1548886792,"
            + "\\\\\"Id\\\\\":\\\\\"sha256:caf27325b298a6730837023a8a342699c8b7b388b8d878966b064a1320043019\\\\\","
            + "\\\\\"Labels\\\\\":null,\\\\\"ParentId\\\\\":\\\\\"\\\\\","
            + "\\\\\"RepoDigests\\\\\":[\\\\\"alpine@sha256"
            + ":b3dbf31b77fd99d9c08f780ce6f5282aba076d70a513a8be859d8d3a4d0c92b8\\\\\"],"
            + "\\\\\"RepoTags\\\\\":[\\\\\"alpine:latest\\\\\"],\\\\\"SharedSize\\\\\":-1,\\\\\"Size\\\\\":5529164,"
            + "\\\\\"VirtualSize\\\\\":5529164}]\\\n"
            + "\",\"statusCodeValue\":200,\"statusCode\":\"OK\"}\n"
            + "```\n"
            + "\n";

    @Test
    public void contextLoads() throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        blogRepository
                .findById(new ObjectId("5d4a74a98bd8238fbd8b59ed"))
                .doOnNext(it -> it.setContent(it.getContent().replace("\\\"", "\"")))
                /*.doOnNext(it -> it.setContent(content))*/
                .flatMap(blogRepository::save)
                .doOnError(e -> log.error("catch err", e))
                .doFinally(it -> {
                    log.info("type={}", it);
                    countDownLatch.countDown();
                })
                .subscribe(it -> log.info("res={}", it));

        countDownLatch.await();
    }
}
